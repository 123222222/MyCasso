/*
 * FluxGarage RoboEyes for ST7789 Displays - ported version
 * Adapted from FluxGarage_RoboEyes (originally for OLED) to work with
 * Adafruit ST7789 displays (ST7789). Changes: use 16-bit color, immediate
 * draws (fillScreen) instead of buffered display->display(), and keep
 * original API/behaviour as much as possible.
 *
 * Original Copyright (C) 2024-2025 Dennis Hoelscher
 * This port preserves the original GPLv3 license.
 * See original: https://github.com/FluxGarage/RoboEyes
 */

#ifndef _FLUXGARAGE_ROBOEYES_ST7789_H
#define _FLUXGARAGE_ROBOEYES_ST7789_H

#include <Adafruit_GFX.h>
#include <Adafruit_ST7789.h>
#include <SPI.h>
#ifdef ARDUINO
#include <Arduino.h>
#endif
#ifndef PI
#define PI 3.14159265358979323846f
#endif

// Display colors (16-bit for ST77xx)
uint16_t BGCOLOR = ST77XX_BLACK; // background and overlays
uint16_t MAINCOLOR = ST77XX_CYAN; // drawings

// For mood type switch
#define DEFAULT 0
#define HAPPY 1
#define SAD 2
#define ANGRY 3
#define TIRED 4
#define SLEEP 5
#define GLEE 6
#define WORRIED 7
#define FOCUSED 8
#define ANNOYED 9
#define SURPRISED 10
#define SKEPTIC 11
#define FRUSTRATED 12
#define SUSPICIOUS 13
#define SQUINT 14
#define FURIOUS 15
#define SCARED 16
#define AWE 17

// For turning things on or off
#define ON 1
#define OFF 0

// For switch "predefined positions"
#define N 1
#define NE 2
#define E 3
#define SE 4
#define S 5
#define SW 6
#define W 7
#define NW 8

// Constructor: takes a reference to the active Adafruit display object
template<typename AdafruitDisplay>
class RoboEyes {
private:

public:

  AdafruitDisplay *display;

  // Screen / framerate
  int screenWidth = 240;
  int screenHeight = 320;
  int frameInterval = 1000/30;
  unsigned long fpsTimer = 0;

  // Moods & flags
  bool tired = 0;
  bool angry = 0;
  bool happy = 0;
  bool sad = 0;
  bool glee = 0;
  bool worried = 0;
  bool focused = 0;
  bool annoyed = 0;
  bool surprised = 0;
  bool skeptic = 0;
  bool frustrated = 0;
  bool suspicious = 0;
  bool squint = 0;
  bool furious = 0;
  bool scared = 0;
  bool awe = 0;
  bool curious = 0;
  bool cyclops = 0;
  bool eyeL_open = 0;
  bool eyeR_open = 0;
  int eyeLheightSaved = 36;
  int eyeRheightSaved = 36;

  // EYE geometry defaults
  int eyeLwidthDefault = 36;
  int eyeLheightDefault = 36;
  int eyeLwidthCurrent = 36;
  int eyeLheightCurrent = 1;
  int eyeLwidthNext = 36;
  int eyeLheightNext = 36;
  int eyeLheightOffset = 0;
  byte eyeLborderRadiusDefault = 8;
  byte eyeLborderRadiusCurrent = 8;
  byte eyeLborderRadiusNext = 8;

  int eyeRwidthDefault = 36;
  int eyeRheightDefault = 36;
  int eyeRwidthCurrent = 36;
  int eyeRheightCurrent = 1;
  int eyeRwidthNext = 36;
  int eyeRheightNext = 36;
  int eyeRheightOffset = 0;
  byte eyeRborderRadiusDefault = 8;
  byte eyeRborderRadiusCurrent = 8;
  byte eyeRborderRadiusNext = 8;

  // Positions
  int spaceBetweenDefault = 10;
  int spaceBetweenCurrent = 10;
  int spaceBetweenNext = 10;

  int eyeLxDefault = 0;
  int eyeLyDefault = 0;
  int eyeLx = 0;
  int eyeLy = 0;
  int eyeLxNext = 0;
  int eyeLyNext = 0;

  int eyeRxDefault = 0;
  int eyeRyDefault = 0;
  int eyeRx = 0;
  int eyeRy = 0;
  int eyeRxNext = 0;
  int eyeRyNext = 0;

  // Eyelid values
  byte eyelidsHeightMax = 18;
  byte eyelidsTiredHeight = 0;
  byte eyelidsTiredHeightNext = 0;
  byte eyelidsTiredHeightPrev = 0;
  byte eyelidsAngryHeight = 0;
  byte eyelidsAngryHeightNext = 0;
  byte eyelidsAngryHeightPrev = 0;
  byte eyelidsHappyBottomOffsetMax = 21;
  byte eyelidsHappyBottomOffset = 0;
  byte eyelidsHappyBottomOffsetNext = 0;
  byte eyelidsHappyBottomOffsetPrev = 0;
  
  // Additional mood eyelids
  byte eyelidsSadHeight = 0;
  byte eyelidsSadHeightNext = 0;
  byte eyelidsSadHeightPrev = 0;
  byte eyelidsGleeBottomOffset = 0;
  byte eyelidsGleeBottomOffsetNext = 0;
  byte eyelidsGleeBottomOffsetPrev = 0;
  byte eyelidsWorriedHeight = 0;
  byte eyelidsWorriedHeightNext = 0;
  byte eyelidsWorriedHeightPrev = 0;
  byte eyelidsFocusedHeight = 0;
  byte eyelidsFocusedHeightNext = 0;
  byte eyelidsFocusedHeightPrev = 0;
  byte eyelidsAnnoyedHeight = 0;
  byte eyelidsAnnoyedHeightNext = 0;
  byte eyelidsAnnoyedHeightPrev = 0;
  byte eyelidsSkepticHeight = 0;
  byte eyelidsSkepticHeightNext = 0;
  byte eyelidsSkepticHeightPrev = 0;
  byte eyelidsFrustratedHeight = 0;
  byte eyelidsFrustratedHeightNext = 0;
  byte eyelidsFrustratedHeightPrev = 0;
  byte eyelidsSuspiciousHeight = 0;
  byte eyelidsSuspiciousHeightNext = 0;
  byte eyelidsSuspiciousHeightPrev = 0;
  byte eyelidsSquintHeight = 0;
  byte eyelidsSquintHeightNext = 0;
  byte eyelidsSquintHeightPrev = 0;
  byte eyelidsFuriousHeight = 0;
  byte eyelidsFuriousHeightNext = 0;
  byte eyelidsFuriousHeightPrev = 0;

  // Macro animations
  bool hFlicker = 0;
  bool hFlickerAlternate = 0;
  byte hFlickerAmplitude = 2;

  bool vFlicker = 0;
  bool vFlickerAlternate = 0;
  byte vFlickerAmplitude = 10;

  bool autoblinker = 0;
  int blinkInterval = 3;
  int blinkIntervalVariation = 2;
  unsigned long blinktimer = 0;

  bool idle = 0;
  int idleInterval = 2;
  int idleIntervalVariation = 2;
  unsigned long idleAnimationTimer = 0;
  byte idleMoodIndex = 0; // Theo dõi mood hiện tại (0-17)

  bool confused = 0;
  unsigned long confusedAnimationTimer = 0;
  int confusedAnimationDuration = 500;
  bool confusedToggle = 1;

  bool laugh = 0;
  unsigned long laughAnimationTimer = 0;
  int laughAnimationDuration = 500;
  bool laughToggle = 1;

  bool sweat = 0;
  byte sweatBorderradius = 3;

  // sweat drops
  int sweat1XPosInitial = 2;
  int sweat1XPos;
  float sweat1YPos = 2;
  int sweat1YPosMax;
  float sweat1Height = 2;
  float sweat1Width = 1;

  int sweat2XPosInitial = 2;
  int sweat2XPos;
  float sweat2YPos = 2;
  int sweat2YPosMax;
  float sweat2Height = 2;
  float sweat2Width = 1;

  int sweat3XPosInitial = 2;
  int sweat3XPos;
  float sweat3YPos = 2;
  int sweat3YPosMax;
  float sweat3Height = 2;
  float sweat3Width = 1;

  // --- Mood transition control & flicker mitigation ---
  bool moodTransitionActive = false;
  unsigned long moodTransitionStart = 0;
  int moodTransitionDuration = 450; // ms
  unsigned long moodBlinkLockUntil = 0; // pause auto-blink during transition
  int warmupFrames = 2; // force initial redraws to populate screen

  // Previous cleared region (for minimal dirty rect union)
  int prevClearX = 0;
  int prevClearY = 0;
  int prevClearW = 0;
  int prevClearH = 0;

  // Simple easing (quadratic)
  float easeInOutQuad(float t){
    if(t < 0.0f) t = 0.0f; else if(t > 1.0f) t = 1.0f;
    return (t < 0.5f) ? (2.0f * t * t) : (1.0f - ((-2.0f * t + 2.0f) * (-2.0f * t + 2.0f)) / 2.0f);
  }

  inline int roundToInt(float v){ return (int)(v >= 0.0f ? v + 0.5f : v - 0.5f); }

  // --- Mood GIF-like animation ---
  bool moodAnimActive = false;
  unsigned long moodAnimStart = 0;
  int moodAnimPeriod = 900; // ms per loop
  // Store bases so animation can modulate around them
  int baseEyeLwidth = 36, baseEyeRwidth = 36;
  int baseEyeLheight = 36, baseEyeRheight = 36;
  byte baseHappyBottom = 0, baseSadTop = 0, baseAngryTop = 0, baseTiredTop = 0;
  // Intensity control (1.0 = default)
  float moodAnimIntensity = 1.0f;
  // Additional lifelike motion parameters
  int moodLfoPeriod = 2200; // ms for slow sway/breathing
  float swayAmpPx = 1.0f;   // vertical sway amplitude
  float sizeAmpPx = 2.0f;   // base eye size swell amplitude
  float lidAmpPx  = 3.0f;   // base eyelid modulation amplitude
  // Micro-saccade (tiny quick eye movement)
  bool microActive = false;
  float microDX = 0.0f, microDY = 0.0f;
  float microDXTarget = 0.0f, microDYTarget = 0.0f;
  unsigned long microStart = 0;
  unsigned long microDuration = 120; // ms
  unsigned long microCooldownNext = 0; // next time allowed to trigger

  // Constructor
  RoboEyes(AdafruitDisplay &disp) : display(&disp) {
    // nothing
  }

  void begin(int width, int height, byte frameRate) {
    screenWidth = width;
    screenHeight = height;
    // Initialize default positions based on screen size
    eyeLwidthDefault = eyeLwidthCurrent = eyeLwidthNext = 36;
    eyeLheightDefault = eyeLheightCurrent = eyeLheightNext = 36;
    spaceBetweenDefault = spaceBetweenCurrent = spaceBetweenNext = 10;
    // compute defaults
    eyeLxDefault = (screenWidth - (eyeLwidthDefault + spaceBetweenDefault + eyeRwidthDefault)) / 2;
    eyeLyDefault = (screenHeight - eyeLheightDefault) / 2;
    eyeLx = eyeLxDefault; eyeLy = eyeLyDefault; eyeLxNext = eyeLx;
    eyeRx = eyeLx + eyeLwidthCurrent + spaceBetweenCurrent;
    eyeRxNext = eyeRx; eyeRy = eyeLy; eyeRyNext = eyeRy;

    // clear screen once
    display->fillScreen(BGCOLOR);

    eyeLheightCurrent = 1;
    eyeRheightCurrent = 1;
    
    setFramerate(frameRate);
  }

  void update(){
    if(millis() - fpsTimer >= frameInterval){
      drawEyes();
      fpsTimer = millis();
    }
  }

  void setFramerate(byte fps){
    frameInterval = 1000 / fps;
  }

  void setDisplayColors(uint16_t background, uint16_t main) {
    BGCOLOR = background;
    MAINCOLOR = main;
  }

  void setWidth(byte leftEye, byte rightEye) {
    eyeLwidthNext = leftEye;
    eyeRwidthNext = rightEye;
    eyeLwidthDefault = leftEye;
    eyeRwidthDefault = rightEye;
  }

  void setHeight(byte leftEye, byte rightEye) {
    eyeLheightNext = leftEye;
    eyeRheightNext = rightEye;
    eyeLheightDefault = leftEye;
    eyeRheightDefault = rightEye;
  }

  void setBorderradius(byte leftEye, byte rightEye) {
    eyeLborderRadiusNext = leftEye;
    eyeRborderRadiusNext = rightEye;
    eyeLborderRadiusDefault = leftEye;
    eyeRborderRadiusDefault = rightEye;
  }

  void setSpacebetween(int space) {
    spaceBetweenNext = space;
    spaceBetweenDefault = space;
  }

  void setMood(unsigned char mood) {
    // Reset tất cả mood flags
    tired = angry = happy = sad = glee = worried = focused = annoyed = 0;
    surprised = skeptic = frustrated = suspicious = squint = furious = scared = awe = 0;
    
    // KHÔNG reset về DEFAULT - giữ nguyên giá trị hiện tại để tránh giật
    // Mỗi mood sẽ set đầy đủ tất cả tham số cần thiết
    // Chỉ reset eyelids về 0 (sẽ được override bởi mood cụ thể)
    eyelidsTiredHeightNext = 0;
    eyelidsAngryHeightNext = 0;
    eyelidsHappyBottomOffsetNext = 0;
    eyelidsSadHeightNext = 0;
    eyelidsGleeBottomOffsetNext = 0;
    eyelidsWorriedHeightNext = 0;
    eyelidsFocusedHeightNext = 0;
    eyelidsAnnoyedHeightNext = 0;
    eyelidsSkepticHeightNext = 0;
    eyelidsFrustratedHeightNext = 0;
    eyelidsSuspiciousHeightNext = 0;
    eyelidsSquintHeightNext = 0;
    eyelidsFuriousHeightNext = 0;  switch(mood){
      case TIRED: {
        tired = 1;
        eyeLwidthNext = eyeLwidthDefault;
        eyeRwidthNext = eyeRwidthDefault;
        eyeLheightNext = eyeLheightDefault;
        eyeRheightNext = eyeRheightDefault;
        eyelidsTiredHeightNext = eyeLheightDefault / 3;
        break;
      }
      case ANGRY: {
        angry = 1;
        eyeLwidthNext = eyeLwidthDefault;
        eyeRwidthNext = eyeRwidthDefault;
        eyeLheightNext = eyeLheightDefault;
        eyeRheightNext = eyeRheightDefault;
        eyelidsAngryHeightNext = eyeLheightDefault / 2;
        break;
      }
      case HAPPY: {
        happy = 1;
        eyeLwidthNext = eyeLwidthDefault;
        eyeRwidthNext = eyeRwidthDefault;
        eyeLheightNext = eyeLheightDefault;
        eyeRheightNext = eyeRheightDefault;
        eyelidsHappyBottomOffsetNext = eyeLheightDefault / 4;
        break;
      }
      case SAD: {
        sad = 1;
        eyeLwidthNext = eyeLwidthDefault;
        eyeRwidthNext = eyeRwidthDefault;
        eyeLheightNext = eyeLheightDefault;
        eyeRheightNext = eyeRheightDefault;
        eyelidsSadHeightNext = eyeLheightDefault / 4;
        break;
      }
      case GLEE: {
        glee = 1;
        eyeLwidthNext = eyeLwidthDefault;
        eyeRwidthNext = eyeRwidthDefault;
        eyeLheightNext = eyeLheightDefault;
        eyeRheightNext = eyeRheightDefault;
        eyelidsGleeBottomOffsetNext = eyeLheightDefault / 3;
        break;
      }
      case WORRIED: {
        worried = 1;
        eyeLwidthNext = eyeLwidthDefault;
        eyeRwidthNext = eyeRwidthDefault;
        eyeLheightNext = eyeLheightDefault;
        eyeRheightNext = eyeRheightDefault;
        eyelidsWorriedHeightNext = eyeLheightDefault / 5;
        break;
      }
      case FOCUSED: {
        focused = 1;
        eyeLwidthNext = eyeLwidthDefault;
        eyeRwidthNext = eyeRwidthDefault;
        eyeLheightNext = eyeLheightDefault;
        eyeRheightNext = eyeRheightDefault;
        eyelidsFocusedHeightNext = eyeLheightDefault / 4;
        break;
      }
      case ANNOYED: {
        annoyed = 1;
        eyeLwidthNext = eyeLwidthDefault;
        eyeRwidthNext = eyeRwidthDefault;
        eyeLheightNext = eyeLheightDefault;
        eyeRheightNext = eyeRheightDefault;
        eyelidsAnnoyedHeightNext = eyeLheightDefault / 5;
        break;
      }
      case SURPRISED: {
        surprised = 1;
        eyeLwidthNext = eyeLwidthDefault * 1.3;
        eyeRwidthNext = eyeRwidthDefault * 1.3;
        eyeLheightNext = eyeLheightDefault * 1.3;
        eyeRheightNext = eyeRheightDefault * 1.3;
        break;
      }
      case SKEPTIC: {
        skeptic = 1;
        eyeLwidthNext = eyeLwidthDefault;
        eyeRwidthNext = eyeRwidthDefault;
        eyeLheightNext = eyeLheightDefault;
        eyeRheightNext = eyeRheightDefault;
        eyelidsSkepticHeightNext = eyeLheightDefault / 3;
        break;
      }
      case FRUSTRATED: {
        frustrated = 1;
        eyeLwidthNext = eyeLwidthDefault;
        eyeRwidthNext = eyeRwidthDefault;
        eyeLheightNext = eyeLheightDefault;
        eyeRheightNext = eyeRheightDefault;
        eyelidsFrustratedHeightNext = eyeLheightDefault / 4;
        break;
      }
      case SUSPICIOUS: {
        suspicious = 1;
        eyeLwidthNext = eyeLwidthDefault;
        eyeRwidthNext = eyeRwidthDefault;
        eyeLheightNext = eyeLheightDefault;
        eyeRheightNext = eyeRheightDefault;
        eyelidsSuspiciousHeightNext = eyeLheightDefault / 3;
        break;
      }
      case SQUINT: {
        squint = 1;
        eyeLwidthNext = eyeLwidthDefault;
        eyeRwidthNext = eyeRwidthDefault;
        eyeLheightNext = eyeLheightDefault;
        eyeRheightNext = eyeRheightDefault;
        eyelidsSquintHeightNext = eyeLheightDefault * 2 / 5;
        break;
      }
      case FURIOUS: {
        furious = 1;
        eyeLwidthNext = eyeLwidthDefault;
        eyeRwidthNext = eyeRwidthDefault;
        eyeLheightNext = eyeLheightDefault;
        eyeRheightNext = eyeRheightDefault;
        eyelidsFuriousHeightNext = eyeLheightDefault / 2;
        break;
      }
      case SCARED: {
        scared = 1;
        eyeLwidthNext = eyeLwidthDefault * 1.2;
        eyeRwidthNext = eyeRwidthDefault * 1.2;
        eyeLheightNext = eyeLheightDefault * 1.2;
        eyeRheightNext = eyeRheightDefault * 1.2;
        break;
      }
      case AWE: {
        awe = 1;
        eyeLwidthNext = eyeLwidthDefault * 1.4;
        eyeRwidthNext = eyeRwidthDefault * 1.4;
        eyeLheightNext = eyeLheightDefault * 1.4;
        eyeRheightNext = eyeRheightDefault * 1.4;
        break;
      }
      case SLEEP: 
        eyeLwidthNext = eyeLwidthDefault;
        eyeRwidthNext = eyeRwidthDefault;
        eyeLheightNext = eyeLheightDefault;
        eyeRheightNext = eyeRheightDefault;
        close(); 
        break;
      default: 
        // DEFAULT - bình thường (kích thước mặc định, không có eyelid effects)
        eyeLwidthNext = eyeLwidthDefault;
        eyeRwidthNext = eyeRwidthDefault;
        eyeLheightNext = eyeLheightDefault;
        eyeRheightNext = eyeRheightDefault;
        break;
    }

  // Start timed mood transition and temporarily pause auto-blink
    moodTransitionActive = true;
    moodTransitionStart = millis();
    moodBlinkLockUntil = moodTransitionStart + (unsigned long)moodTransitionDuration;

    // Setup per-mood GIF-like animation bases and flags
    baseEyeLwidth = eyeLwidthNext; baseEyeRwidth = eyeRwidthNext;
    baseEyeLheight = eyeLheightNext; baseEyeRheight = eyeRheightNext;
    // Save current heights for blink restoration
    eyeLheightSaved = eyeLheightNext;
    eyeRheightSaved = eyeRheightNext;
    baseHappyBottom = eyelidsHappyBottomOffsetNext;
    baseSadTop = eyelidsSadHeightNext;
    baseAngryTop = eyelidsAngryHeightNext;
    baseTiredTop = eyelidsTiredHeightNext;
    moodAnimStart = millis();
    // Lifelike tuning per mood
    switch(mood){
      case HAPPY:
      case GLEE:
        moodAnimActive = true; moodAnimPeriod = 900; moodLfoPeriod = 1500; swayAmpPx = 1.2f; sizeAmpPx = 2.0f; lidAmpPx = 3.0f; break;
      case SAD:
        moodAnimActive = true; moodAnimPeriod = 1200; moodLfoPeriod = 2200; swayAmpPx = 1.0f; sizeAmpPx = 1.5f; lidAmpPx = 2.0f; break;
      case ANGRY:
      case FURIOUS:
        moodAnimActive = true; moodAnimPeriod = 700; moodLfoPeriod = 1400; swayAmpPx = 0.6f; sizeAmpPx = 1.5f; lidAmpPx = 2.5f; break;
      case TIRED:
        moodAnimActive = true; moodAnimPeriod = 1400; moodLfoPeriod = 2800; swayAmpPx = 1.6f; sizeAmpPx = 1.2f; lidAmpPx = 1.6f; break;
      case SURPRISED:
      case AWE:
      case SCARED:
        moodAnimActive = true; moodAnimPeriod = 800; moodLfoPeriod = 1600; swayAmpPx = 0.8f; sizeAmpPx = 2.2f; lidAmpPx = 2.2f; break;
      default:
        moodAnimActive = (mood != SLEEP); moodAnimPeriod = 1000; moodLfoPeriod = 2000; swayAmpPx = 0.8f; sizeAmpPx = 1.6f; lidAmpPx = 2.0f; break;
    }
    // Reset micro-saccade scheduling so it doesn't trigger immediately after mood change
    microActive = false; microDX = microDY = microDXTarget = microDYTarget = 0.0f; microStart = 0; microCooldownNext = millis() + 900;
  }

  int getScreenConstraint_X(){
    return screenWidth - eyeLwidthCurrent - spaceBetweenCurrent - eyeRwidthCurrent;
  }

  int getScreenConstraint_Y(){
    return screenHeight - eyeLheightDefault;
  }

  void setPosition(unsigned char position){
    // Manual control - chỉ di chuyển vị trí, không thay đổi kích thước
    // Không reset kích thước/mood về mặc định để tránh nháy giữa DEFAULT và mood hiện tại
    
    // Always keep eyes centered vertically
    eyeLyNext = getScreenConstraint_Y()/2;
    
    switch(position){
      case W: 
        eyeLxNext = 0; 
        break;
        
      case E: 
        eyeLxNext = getScreenConstraint_X(); 
        break;
        
      default: 
        // GIỮA (mặc định)
        eyeLxNext = getScreenConstraint_X()/2; 
        break;
    }
  }

  void setPositionAuto(unsigned char position){
    // Auto idle mode - chỉ di chuyển vị trí, giữ nguyên kích thước/mood hiện tại
    
    switch(position){
      case N: 
        eyeLxNext = getScreenConstraint_X()/2; 
        eyeLyNext = 0;
        break;
        
      case NE: 
        eyeLxNext = getScreenConstraint_X(); 
        eyeLyNext = 0;
        break;
        
      case E: 
        eyeLxNext = getScreenConstraint_X(); 
        eyeLyNext = getScreenConstraint_Y()/2;
        break;
        
      case SE: 
        eyeLxNext = getScreenConstraint_X(); 
        eyeLyNext = getScreenConstraint_Y();
        break;
        
      case S: 
        eyeLxNext = getScreenConstraint_X()/2; 
        eyeLyNext = getScreenConstraint_Y();
        break;
        
      case SW: 
        eyeLxNext = 0; 
        eyeLyNext = getScreenConstraint_Y();
        break;
        
      case W: 
        eyeLxNext = 0; 
        eyeLyNext = getScreenConstraint_Y()/2;
        break;
        
      case NW: 
        eyeLxNext = 0; 
        eyeLyNext = 0;
        break;
        
      default: 
        eyeLxNext = getScreenConstraint_X()/2; 
        eyeLyNext = getScreenConstraint_Y()/2; 
        break;
    }
  }  void setAutoblinker(bool active, int interval, int variation){ autoblinker = active; blinkInterval = interval; blinkIntervalVariation = variation; }
  void setAutoblinker(bool active){ autoblinker = active; }
  void setIdleMode(bool active, int interval, int variation){ idle = active; idleInterval = interval; idleIntervalVariation = variation; }
  void setIdleMode(bool active){ idle = active; }
  void setCuriosity(bool curiousBit){ curious = curiousBit; }
  void setCyclops(bool cyclopsBit){ cyclops = cyclopsBit; }
  void setHFlicker(bool flickerBit, byte Amplitude){ hFlicker = flickerBit; hFlickerAmplitude = Amplitude; }
  void setHFlicker(bool flickerBit){ hFlicker = flickerBit; }
  void setVFlicker(bool flickerBit, byte Amplitude){ vFlicker = flickerBit; vFlickerAmplitude = Amplitude; }
  void setVFlicker(bool flickerBit){ vFlicker = flickerBit; }
  void setSweat(bool sweatBit){ sweat = sweatBit; }
  void setMoodAnimation(bool active, int periodMs){ moodAnimActive = active; if(periodMs > 0) moodAnimPeriod = periodMs; }
  void setMoodAnimIntensity(float intensity){ if(intensity < 0.2f) intensity = 0.2f; if(intensity > 3.0f) intensity = 3.0f; moodAnimIntensity = intensity; }

  void close(){ eyeLheightSaved = eyeLheightNext; eyeRheightSaved = eyeRheightNext; eyeLheightNext = 1; eyeRheightNext = 1; eyeL_open = 0; eyeR_open = 0; }
  void open(){ eyeL_open = 1; eyeR_open = 1; }
  void blink(){ close(); open(); }
  void close(bool left, bool right){ if(left){ eyeLheightSaved = eyeLheightNext; eyeLheightNext = 1; eyeL_open = 0; } if(right){ eyeRheightSaved = eyeRheightNext; eyeRheightNext = 1; eyeR_open = 0; } }
  void open(bool left, bool right){ if(left) eyeL_open = 1; if(right) eyeR_open = 1; }
  void blink(bool left, bool right){ close(left,right); open(left,right); }
  void anim_confused(){ confused = 1; }
  void anim_laugh(){ laugh = 1; }

  void drawEyes(){
    // Check if we need to redraw (only if values are changing significantly)
    // Reducing unnecessary full-area clears helps eliminate visible flicker
    bool needsRedraw = false;
    // Ensure first frames always draw to populate screen
    if(warmupFrames > 0){ needsRedraw = true; warmupFrames--; }
    
    // Check for any animation in progress (increased threshold to reduce unnecessary redraws)
    if (abs(eyeLheightCurrent - eyeLheightNext) > 2 ||
        abs(eyeRheightCurrent - eyeRheightNext) > 2 ||
        abs(eyeLwidthCurrent - eyeLwidthNext) > 2 ||
        abs(eyeLx - eyeLxNext) > 2 ||
        abs(eyeLy - eyeLyNext) > 2 ||
        abs(spaceBetweenCurrent - spaceBetweenNext) > 1 ||
        sweat || laugh || confused) {
      needsRedraw = true;
    }
    
    // Pre-calculations
    if(curious){
      if(eyeLxNext<=10) eyeLheightOffset=8; else if (eyeLxNext>=(getScreenConstraint_X()-10) && cyclops) eyeLheightOffset=8; else eyeLheightOffset=0;
      if(eyeRxNext>=screenWidth-eyeRwidthCurrent-10) eyeRheightOffset=8; else eyeRheightOffset=0;
    } else { eyeLheightOffset=0; eyeRheightOffset=0; }

    // Compute mood transition easing factor (controls how fast parameters move toward targets)
    float moodT = 1.0f;
    if(moodTransitionActive){
      unsigned long el = millis() - moodTransitionStart;
      if(el >= (unsigned long)moodTransitionDuration){ moodTransitionActive = false; moodT = 1.0f; }
      else moodT = (float)el / (float)moodTransitionDuration;
    }
    float moodEase = easeInOutQuad(moodT);
    // Eye shape smoothing factor (slower at start, faster near end)
    float eyeAlpha = 0.18f + 0.32f * moodEase;   // 0.18 .. 0.5
    float widthAlpha = eyeAlpha;
    float radiusAlpha = 0.16f + 0.34f * moodEase; // 0.16 .. 0.5

    // Heights include offsets from curiosity
    int eyeLheightTarget = eyeLheightNext + eyeLheightOffset;
    int eyeRheightTarget = eyeRheightNext + eyeRheightOffset;
    eyeLheightCurrent += (eyeLheightTarget - eyeLheightCurrent) * eyeAlpha;
    eyeLy += ((eyeLheightDefault-eyeLheightCurrent)/2);
    eyeLy -= eyeLheightOffset/2;
    eyeRheightCurrent += (eyeRheightTarget - eyeRheightCurrent) * eyeAlpha;
    eyeRy += (eyeRheightDefault-eyeRheightCurrent)/2;
    eyeRy -= eyeRheightOffset/2;

  if(eyeL_open){ if(eyeLheightCurrent <= 1 + eyeLheightOffset) eyeLheightNext = max(2, eyeLheightSaved); }
  if(eyeR_open){ if(eyeRheightCurrent <= 1 + eyeRheightOffset) eyeRheightNext = max(2, eyeRheightSaved); }

  eyeLwidthCurrent += (eyeLwidthNext - eyeLwidthCurrent) * widthAlpha;
  eyeRwidthCurrent += (eyeRwidthNext - eyeRwidthCurrent) * widthAlpha;
  spaceBetweenCurrent += (spaceBetweenNext - spaceBetweenCurrent) * 0.35f; // mild smoothing for spacing

  eyeLx = (eyeLx + eyeLxNext)/2;
  eyeLy = (eyeLy + eyeLyNext)/2;
    
    // Snap to target when close enough to stop micro-movements
    if (abs(eyeLx - eyeLxNext) <= 2) eyeLx = eyeLxNext;
    if (abs(eyeLy - eyeLyNext) <= 2) eyeLy = eyeLyNext;
    if (abs(eyeLwidthCurrent - eyeLwidthNext) <= 1) eyeLwidthCurrent = eyeLwidthNext;
    if (abs(eyeRwidthCurrent - eyeRwidthNext) <= 1) eyeRwidthCurrent = eyeRwidthNext;
    if (abs(eyeLheightCurrent - eyeLheightNext) <= 1) eyeLheightCurrent = eyeLheightNext;
    if (abs(eyeRheightCurrent - eyeRheightNext) <= 1) eyeRheightCurrent = eyeRheightNext;
    
    eyeRxNext = eyeLxNext + eyeLwidthCurrent + spaceBetweenCurrent;
    eyeRyNext = eyeLyNext;
    eyeRx = (eyeRx + eyeRxNext)/2;
    eyeRy = (eyeRy + eyeRyNext)/2;
    
    if (abs(eyeRx - eyeRxNext) <= 2) eyeRx = eyeRxNext;
    if (abs(eyeRy - eyeRyNext) <= 2) eyeRy = eyeRyNext;

  eyeLborderRadiusCurrent += (eyeLborderRadiusNext - eyeLborderRadiusCurrent) * radiusAlpha;
  eyeRborderRadiusCurrent += (eyeRborderRadiusNext - eyeRborderRadiusCurrent) * radiusAlpha;

  // Autoblink (paused briefly during mood transition to avoid overlap flicker)
  if(autoblinker){ if(millis() >= blinktimer && millis() >= moodBlinkLockUntil){ blink(); blinktimer = millis() + (blinkInterval*1000) + (random(blinkIntervalVariation)*1000); } }

    // Laugh
    if(laugh){ if(laughToggle){ setVFlicker(1,5); laughAnimationTimer = millis(); laughToggle = 0; } else if(millis() >= laughAnimationTimer + laughAnimationDuration){ setVFlicker(0,0); laughToggle = 1; laugh = 0; } }

    // Confused
    if(confused){ if(confusedToggle){ setHFlicker(1,20); confusedAnimationTimer = millis(); confusedToggle = 0; } else if(millis() >= confusedAnimationTimer + confusedAnimationDuration){ setHFlicker(0,0); confusedToggle = 1; confused = 0; } }

    // Idle - Tự động chuyển mood theo thứ tự tại vị trí giữa - chuyển mượt mà
    if(idle){ 
      unsigned long currentTime = millis();
      
      if(currentTime >= idleAnimationTimer) {
        // Đảm bảo ở giữa màn hình
        setPosition(DEFAULT);
        
        // Chuyển mood theo thứ tự qua các mood (loại bỏ DEFAULT để tránh cảm giác giật qua lại)
        unsigned char moods[17] = {HAPPY, SAD, ANGRY, TIRED, SLEEP, GLEE, WORRIED, 
                                    FOCUSED, ANNOYED, SURPRISED, SKEPTIC, FRUSTRATED, 
                                    SUSPICIOUS, SQUINT, FURIOUS, SCARED, AWE};
        setMood(moods[idleMoodIndex]);
        
        // Tăng index cho lần sau
        idleMoodIndex = (idleMoodIndex + 1) % 17; // 0..16, 0..16...
        
        // Đợi 4 giây rồi chuyển mood tiếp theo (không chớp mắt)
        idleAnimationTimer = currentTime + 4000;
      }
    }

  // Lifesize slow sway (breathing-like)
    if(moodAnimActive){
      unsigned long tLfo = millis() - moodAnimStart;
      float phaseLfo = (2.0f * PI * (float)(tLfo % moodLfoPeriod)) / (float)moodLfoPeriod;
      float sway = sin(phaseLfo) * swayAmpPx * moodAnimIntensity;
      eyeLy += sway; eyeRy += sway;
    }

  // Update micro-saccade state
    unsigned long nowMs = millis();
    if(!microActive && nowMs >= microCooldownNext){
      // 1 in 3 chance to micro-saccade at allowed time
      if(random(3) == 0){
        microActive = true;
        microStart = nowMs;
        microDuration = 120 + (random(3) * 40); // 120..200ms
        float amp = 1.0f * moodAnimIntensity; // base amplitude
        if(angry || furious) amp = 1.6f * moodAnimIntensity;
        if(tired) amp = 0.6f * moodAnimIntensity;
        microDXTarget = ((random(3) - 1) * amp); // -amp, 0, +amp
        microDYTarget = ((random(3) - 1) * amp);
      } else {
        microCooldownNext = nowMs + 500 + random(900); // try again later
      }
    }
    if(microActive){
      float k = 0.45f; // quick ease
      microDX += (microDXTarget - microDX) * k;
      microDY += (microDYTarget - microDY) * k;
      if(nowMs >= microStart + microDuration){
        // return to zero and end
        microDXTarget = 0.0f; microDYTarget = 0.0f;
        // when back near zero, end and schedule next cooldown
        if((microDX > -0.1f && microDX < 0.1f) && (microDY > -0.1f && microDY < 0.1f)){
          microActive = false; microCooldownNext = nowMs + 700 + random(1200);
        }
      }
      eyeLx += microDX; eyeRx += microDX; eyeLy += microDY; eyeRy += microDY;
    }

  // Flicker offsets
    if(hFlicker){ if(hFlickerAlternate){ eyeLx += hFlickerAmplitude; eyeRx += hFlickerAmplitude; } else { eyeLx -= hFlickerAmplitude; eyeRx -= hFlickerAmplitude; } hFlickerAlternate = !hFlickerAlternate; }
    if(vFlicker){ if(vFlickerAlternate){ eyeLy += vFlickerAmplitude; eyeRy += vFlickerAmplitude; } else { eyeLy -= vFlickerAmplitude; eyeRy -= vFlickerAmplitude; } vFlickerAlternate = !vFlickerAlternate; }

    // Eyelid transitions are now handled in setMood() - no need to recalculate here
    // The smoothing below will automatically transition from current to next values

    // Apply GIF-like per-mood animation by modulating target values around their bases
    if(moodAnimActive){
      unsigned long t = millis() - moodAnimStart;
      float phase = (2.0f * PI * (float)(t % moodAnimPeriod)) / (float)moodAnimPeriod;
      float sinp = sin(phase);
      // Subtle amplitudes per mood
      if(happy || glee){
        eyelidsHappyBottomOffsetNext = baseHappyBottom + (byte)roundToInt(lidAmpPx * moodAnimIntensity * sinp);
        int d = roundToInt(sizeAmpPx * moodAnimIntensity * sinp);
        eyeLheightNext = baseEyeLheight + d;
        eyeRheightNext = baseEyeRheight + d;
      }
      if(sad){
        float s = (sinp>0?sinp:0);
        eyelidsSadHeightNext = baseSadTop + (byte)roundToInt((lidAmpPx-1.0f) * moodAnimIntensity * s); // nhẹ, chỉ khi sin>0
      }
      if(angry || furious){
        float s = (sinp<0?-sinp:0);
        eyelidsAngryHeightNext = baseAngryTop + (byte)roundToInt((lidAmpPx-0.5f) * moodAnimIntensity * s); // giật nhẹ nắp trên
      }
      if(tired){
        float s = (sinp<0?-sinp:0);
        eyelidsTiredHeightNext = baseTiredTop + (byte)roundToInt((lidAmpPx-1.4f) * moodAnimIntensity * s);
      }
      if(surprised || awe){
        int d = roundToInt(sizeAmpPx * moodAnimIntensity * sinp);
        eyeLwidthNext = baseEyeLwidth + d;
        eyeRwidthNext = baseEyeRwidth + d;
        eyeLheightNext = baseEyeLheight + d;
        eyeRheightNext = baseEyeRheight + d;
      }
    }

    // Check if mood overlays are changing
    if (eyelidsTiredHeight != eyelidsTiredHeightPrev ||
        eyelidsAngryHeight != eyelidsAngryHeightPrev ||
        eyelidsHappyBottomOffset != eyelidsHappyBottomOffsetPrev ||
        eyelidsSadHeight != eyelidsSadHeightPrev ||
        eyelidsGleeBottomOffset != eyelidsGleeBottomOffsetPrev ||
        eyelidsWorriedHeight != eyelidsWorriedHeightPrev ||
        eyelidsFocusedHeight != eyelidsFocusedHeightPrev ||
        eyelidsAnnoyedHeight != eyelidsAnnoyedHeightPrev ||
        eyelidsSkepticHeight != eyelidsSkepticHeightPrev ||
        eyelidsFrustratedHeight != eyelidsFrustratedHeightPrev ||
        eyelidsSuspiciousHeight != eyelidsSuspiciousHeightPrev ||
        eyelidsSquintHeight != eyelidsSquintHeightPrev ||
        eyelidsFuriousHeight != eyelidsFuriousHeightPrev ||
        abs(eyelidsTiredHeight - eyelidsTiredHeightNext) > 1 ||
        abs(eyelidsAngryHeight - eyelidsAngryHeightNext) > 1 ||
        abs(eyelidsHappyBottomOffset - eyelidsHappyBottomOffsetNext) > 1 ||
        abs(eyelidsSadHeight - eyelidsSadHeightNext) > 1 ||
        abs(eyelidsGleeBottomOffset - eyelidsGleeBottomOffsetNext) > 1) {
      needsRedraw = true;
    }

    if(cyclops){ eyeRwidthCurrent = 0; eyeRheightCurrent = 0; spaceBetweenCurrent = 0; }

    // If nothing meaningful changed, skip drawing to avoid clearing/redrawing the region.
    // This prevents visible flicker on ST7789 when repeatedly wiping a large area.
    if(!needsRedraw){
      return;
    }

  // Compute a conservative dirty rectangle around both eyes and clear only that,
    // but union it with the previous cleared rectangle to avoid trails.
    int eyeL_w = eyeLwidthCurrent;
    int eyeL_h = max(2, eyeLheightCurrent);
    int eyeR_w = eyeRwidthCurrent;
    int eyeR_h = max(2, eyeRheightCurrent);

    // Margins to cover rounded corners and eyelids overlays
    const int margin = max(eyeLborderRadiusCurrent, eyeRborderRadiusCurrent) + 6;

    int l_x1 = eyeLx - margin;
    int l_y1 = eyeLy - margin;
    int l_x2 = eyeLx + eyeL_w + margin;
    int l_y2 = eyeLy + eyeL_h + margin;

    int r_x1 = cyclops ? l_x1 : (eyeRx - margin);
    int r_y1 = cyclops ? l_y1 : (eyeRy - margin);
    int r_x2 = cyclops ? l_x2 : (eyeRx + eyeR_w + margin);
    int r_y2 = cyclops ? l_y2 : (eyeRy + eyeR_h + margin);

    // Union rectangle (current frame)
    int clearX = min(l_x1, r_x1);
    int clearY = min(l_y1, r_y1);
    int clearX2 = max(l_x2, r_x2);
    int clearY2 = max(l_y2, r_y2);
    int clearW = clearX2 - clearX;
    int clearH = clearY2 - clearY;

    // Union with previous cleared rectangle
    if(prevClearW > 0 && prevClearH > 0){
      int uX = min(clearX, prevClearX);
      int uY = min(clearY, prevClearY);
      int uX2 = max(clearX + clearW, prevClearX + prevClearW);
      int uY2 = max(clearY + clearH, prevClearY + prevClearH);
      clearX = uX; clearY = uY; clearW = uX2 - uX; clearH = uY2 - uY;
    }

    // Clamp to screen bounds
    if(clearX < 0){ clearW += clearX; clearX = 0; }
    if(clearY < 0){ clearH += clearY; clearY = 0; }
    if(clearX + clearW > screenWidth){ clearW = screenWidth - clearX; }
    if(clearY + clearH > screenHeight){ clearH = screenHeight - clearY; }

    // Clear only the small union region around the eyes
    if(clearW > 0 && clearH > 0){
      display->fillRect(clearX, clearY, clearW, clearH, BGCOLOR);
    }

    // Save current clear rect for next frame union
    prevClearX = clearX; prevClearY = clearY; prevClearW = clearW; prevClearH = clearH;

  // Draw eyes
    display->fillRoundRect(eyeLx, eyeLy, eyeLwidthCurrent, eyeLheightCurrent, eyeLborderRadiusCurrent, MAINCOLOR);
  if(!cyclops) display->fillRoundRect(eyeRx, eyeRy, eyeRwidthCurrent, eyeRheightCurrent, eyeRborderRadiusCurrent, MAINCOLOR);

    // Tired eyelids (top)
    eyelidsTiredHeight = (eyelidsTiredHeight * 2 + eyelidsTiredHeightNext * 8) / 10; // Smooth nhanh (80% target, 20% current)
    if(!cyclops){
      display->fillTriangle(eyeLx, eyeLy-1, eyeLx+eyeLwidthCurrent, eyeLy-1, eyeLx, eyeLy+eyelidsTiredHeight-1, BGCOLOR);
      display->fillTriangle(eyeRx, eyeRy-1, eyeRx+eyeRwidthCurrent, eyeRy-1, eyeRx+eyeRwidthCurrent, eyeRy+eyelidsTiredHeight-1, BGCOLOR);
    } else {
      display->fillTriangle(eyeLx, eyeLy-1, eyeLx+(eyeLwidthCurrent/2), eyeLy-1, eyeLx, eyeLy+eyelidsTiredHeight-1, BGCOLOR);
      display->fillTriangle(eyeLx+(eyeLwidthCurrent/2), eyeLy-1, eyeLx+eyeLwidthCurrent, eyeLy-1, eyeLx+eyeLwidthCurrent, eyeLy+eyelidsTiredHeight-1, BGCOLOR);
  }
  eyelidsTiredHeightPrev = eyelidsTiredHeight;

    // Angry eyelids
    eyelidsAngryHeight = (eyelidsAngryHeight * 2 + eyelidsAngryHeightNext * 8) / 10; // Smooth nhanh
    if(!cyclops){
      display->fillTriangle(eyeLx, eyeLy-1, eyeLx+eyeLwidthCurrent, eyeLy-1, eyeLx+eyeLwidthCurrent, eyeLy+eyelidsAngryHeight-1, BGCOLOR);
      display->fillTriangle(eyeRx, eyeRy-1, eyeRx+eyeRwidthCurrent, eyeRy-1, eyeRx, eyeRy+eyelidsAngryHeight-1, BGCOLOR);
    } else {
      display->fillTriangle(eyeLx, eyeLy-1, eyeLx+(eyeLwidthCurrent/2), eyeLy-1, eyeLx+(eyeLwidthCurrent/2), eyeLy+eyelidsAngryHeight-1, BGCOLOR);
      display->fillTriangle(eyeLx+(eyeLwidthCurrent/2), eyeLy-1, eyeLx+eyeLwidthCurrent, eyeLy-1, eyeLx+(eyeLwidthCurrent/2), eyeLy+eyelidsAngryHeight-1, BGCOLOR);
    }
  eyelidsAngryHeightPrev = eyelidsAngryHeight;

  // Happy bottom eyelids
  float lidAlpha = 0.20f + 0.55f * moodEase; // 0.2 .. 0.75
  eyelidsHappyBottomOffset += (eyelidsHappyBottomOffsetNext - eyelidsHappyBottomOffset) * lidAlpha;
    display->fillRoundRect(eyeLx-1, (eyeLy+eyeLheightCurrent)-eyelidsHappyBottomOffset+1, eyeLwidthCurrent+2, eyeLheightDefault, eyeLborderRadiusCurrent, BGCOLOR);
    if(!cyclops) display->fillRoundRect(eyeRx-1, (eyeRy+eyeRheightCurrent)-eyelidsHappyBottomOffset+1, eyeRwidthCurrent+2, eyeRheightDefault, eyeRborderRadiusCurrent, BGCOLOR);
  eyelidsHappyBottomOffsetPrev = eyelidsHappyBottomOffset;

  // Sad eyelids (top, nhẹ hơn tired)
  eyelidsSadHeight += (eyelidsSadHeightNext - eyelidsSadHeight) * lidAlpha;
    if(!cyclops){
      display->fillTriangle(eyeLx, eyeLy-1, eyeLx+eyeLwidthCurrent, eyeLy-1, eyeLx, eyeLy+eyelidsSadHeight-1, BGCOLOR);
      display->fillTriangle(eyeRx, eyeRy-1, eyeRx+eyeRwidthCurrent, eyeRy-1, eyeRx+eyeRwidthCurrent, eyeRy+eyelidsSadHeight-1, BGCOLOR);
    }
  eyelidsSadHeightPrev = eyelidsSadHeight;
    
  // Glee bottom eyelids (cong lên như cười, mạnh hơn happy)
  eyelidsGleeBottomOffset += (eyelidsGleeBottomOffsetNext - eyelidsGleeBottomOffset) * lidAlpha;
    display->fillRoundRect(eyeLx-1, (eyeLy+eyeLheightCurrent)-eyelidsGleeBottomOffset+1, eyeLwidthCurrent+2, eyeLheightDefault, eyeLborderRadiusCurrent, BGCOLOR);
    if(!cyclops) display->fillRoundRect(eyeRx-1, (eyeRy+eyeRheightCurrent)-eyelidsGleeBottomOffset+1, eyeRwidthCurrent+2, eyeRheightDefault, eyeRborderRadiusCurrent, BGCOLOR);
  eyelidsGleeBottomOffsetPrev = eyelidsGleeBottomOffset;
    
  // Worried eyelids (nhẹ)
  eyelidsWorriedHeight += (eyelidsWorriedHeightNext - eyelidsWorriedHeight) * lidAlpha;
    if(!cyclops){
      display->fillTriangle(eyeLx, eyeLy-1, eyeLx+eyeLwidthCurrent, eyeLy-1, eyeLx+eyeLwidthCurrent/2, eyeLy+eyelidsWorriedHeight-1, BGCOLOR);
      display->fillTriangle(eyeRx, eyeRy-1, eyeRx+eyeRwidthCurrent, eyeRy-1, eyeRx+eyeRwidthCurrent/2, eyeRy+eyelidsWorriedHeight-1, BGCOLOR);
    }
  eyelidsWorriedHeightPrev = eyelidsWorriedHeight;
    
  // Focused eyelids (nhắm vừa phải)
  eyelidsFocusedHeight += (eyelidsFocusedHeightNext - eyelidsFocusedHeight) * lidAlpha;
    if(!cyclops){
      display->fillRect(eyeLx, eyeLy-1, eyeLwidthCurrent, eyelidsFocusedHeight, BGCOLOR);
      display->fillRect(eyeRx, eyeRy-1, eyeRwidthCurrent, eyelidsFocusedHeight, BGCOLOR);
    }
  eyelidsFocusedHeightPrev = eyelidsFocusedHeight;
    
  // Annoyed eyelids (như tired nhưng nhẹ hơn)
  eyelidsAnnoyedHeight += (eyelidsAnnoyedHeightNext - eyelidsAnnoyedHeight) * lidAlpha;
    if(!cyclops){
      display->fillTriangle(eyeLx, eyeLy-1, eyeLx+eyeLwidthCurrent, eyeLy-1, eyeLx, eyeLy+eyelidsAnnoyedHeight-1, BGCOLOR);
      display->fillTriangle(eyeRx, eyeRy-1, eyeRx+eyeRwidthCurrent, eyeRy-1, eyeRx+eyeRwidthCurrent, eyeRy+eyelidsAnnoyedHeight-1, BGCOLOR);
    }
  eyelidsAnnoyedHeightPrev = eyelidsAnnoyedHeight;
    
  // Skeptic eyelids (1 mắt nhắm hơn - chỉ left)
  eyelidsSkepticHeight += (eyelidsSkepticHeightNext - eyelidsSkepticHeight) * lidAlpha;
    display->fillRect(eyeLx, eyeLy-1, eyeLwidthCurrent, eyelidsSkepticHeight, BGCOLOR);
  eyelidsSkepticHeightPrev = eyelidsSkepticHeight;
    
  // Frustrated eyelids (nhắm vừa)
  eyelidsFrustratedHeight += (eyelidsFrustratedHeightNext - eyelidsFrustratedHeight) * lidAlpha;
    if(!cyclops){
      display->fillRect(eyeLx, eyeLy-1, eyeLwidthCurrent, eyelidsFrustratedHeight, BGCOLOR);
      display->fillRect(eyeRx, eyeRy-1, eyeRwidthCurrent, eyelidsFrustratedHeight, BGCOLOR);
    }
  eyelidsFrustratedHeightPrev = eyelidsFrustratedHeight;
    
  // Suspicious eyelids (nheo mắt)
  eyelidsSuspiciousHeight += (eyelidsSuspiciousHeightNext - eyelidsSuspiciousHeight) * lidAlpha;
    if(!cyclops){
      display->fillRect(eyeLx, eyeLy-1, eyeLwidthCurrent, eyelidsSuspiciousHeight, BGCOLOR);
      display->fillRect(eyeRx, eyeRy-1, eyeRwidthCurrent, eyelidsSuspiciousHeight, BGCOLOR);
    }
  eyelidsSuspiciousHeightPrev = eyelidsSuspiciousHeight;
    
  // Squint eyelids (nhắm nhiều)
  eyelidsSquintHeight += (eyelidsSquintHeightNext - eyelidsSquintHeight) * lidAlpha;
    if(!cyclops){
      display->fillRect(eyeLx, eyeLy-1, eyeLwidthCurrent, eyelidsSquintHeight, BGCOLOR);
      display->fillRect(eyeRx, eyeRy-1, eyeRwidthCurrent, eyelidsSquintHeight, BGCOLOR);
    }
  eyelidsSquintHeightPrev = eyelidsSquintHeight;
    
  // Furious eyelids (như angry nhưng mạnh hơn)
  eyelidsFuriousHeight += (eyelidsFuriousHeightNext - eyelidsFuriousHeight) * lidAlpha;
    if(!cyclops){
      display->fillTriangle(eyeLx, eyeLy-1, eyeLx+eyeLwidthCurrent, eyeLy-1, eyeLx+eyeLwidthCurrent, eyeLy+eyelidsFuriousHeight-1, BGCOLOR);
      display->fillTriangle(eyeRx, eyeRy-1, eyeRx+eyeRwidthCurrent, eyeRy-1, eyeRx, eyeRy+eyelidsFuriousHeight-1, BGCOLOR);
    }
  eyelidsFuriousHeightPrev = eyelidsFuriousHeight;

  // Sweat
    if(sweat){
      if(sweat1YPos <= sweat1YPosMax) sweat1YPos += 0.5; else { sweat1XPosInitial = random(30); sweat1YPos = 2; sweat1YPosMax = (random(10)+10); sweat1Width = 1; sweat1Height = 2; }
      if(sweat1YPos <= sweat1YPosMax/2) { sweat1Width += 0.5; sweat1Height += 0.5; } else { sweat1Width -= 0.1; sweat1Height -= 0.5; }
      sweat1XPos = sweat1XPosInitial - (sweat1Width/2);
      display->fillRoundRect(sweat1XPos, sweat1YPos, (int)sweat1Width, (int)sweat1Height, sweatBorderradius, MAINCOLOR);

      if(sweat2YPos <= sweat2YPosMax) sweat2YPos += 0.5; else { sweat2XPosInitial = random((screenWidth-60))+30; sweat2YPos = 2; sweat2YPosMax = (random(10)+10); sweat2Width = 1; sweat2Height = 2; }
      if(sweat2YPos <= sweat2YPosMax/2) { sweat2Width += 0.5; sweat2Height += 0.5; } else { sweat2Width -= 0.1; sweat2Height -= 0.5; }
      sweat2XPos = sweat2XPosInitial - (sweat2Width/2);
      display->fillRoundRect(sweat2XPos, sweat2YPos, (int)sweat2Width, (int)sweat2Height, sweatBorderradius, MAINCOLOR);

      if(sweat3YPos <= sweat3YPosMax) sweat3YPos += 0.5; else { sweat3XPosInitial = (screenWidth-30)+(random(30)); sweat3YPos = 2; sweat3YPosMax = (random(10)+10); sweat3Width = 1; sweat3Height = 2; }
      if(sweat3YPos <= sweat3YPosMax/2) { sweat3Width += 0.5; sweat3Height += 0.5; } else { sweat3Width -= 0.1; sweat3Height -= 0.5; }
      sweat3XPos = sweat3XPosInitial - (sweat3Width/2);
      display->fillRoundRect(sweat3XPos, sweat3YPos, (int)sweat3Width, (int)sweat3Height, sweatBorderradius, MAINCOLOR);
    }

  }

};

#endif
